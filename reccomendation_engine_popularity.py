# -*- coding: utf-8 -*-
"""RECCOMENDATION_ENGINE_POPULARITY.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m2jTeDTLHgPBxs2VSrCinsI5XUKt4W9w
"""



#IMPORT LIBRARIES

import pandas as pd
import ipywidgets as widgets
from ipywidgets import interact
import matplotlib.pyplot as plt
import seaborn as sns
from IPython.display import display, clear_output
from surprise import Reader, Dataset, SVD
from surprise.model_selection import train_test_split
import pandas as pd
import streamlit as st

# Load the dataset
file_path = 'https://github.com/andercodder/APAI-TASK-3/blob/cdbe037e3973979fdbb00e7689bdb7c7b189de9f/song_dataset.csv'
data = pd.read_csv(file_path)

"""# Task 1: Exploratory Data Analysis

"""

data.head()

data.info()

# 1. Most Listened Songs
most_listened_songs = (
    data.groupby(['song', 'title', 'artist_name'])
    .agg({'play_count': 'sum'})
    .reset_index()
    .sort_values(by='play_count', ascending=False)
    .head(10)
)

# Visualization: Most Listened Songs
plt.figure(figsize=(10, 6))
sns.barplot(x='play_count', y='title', legend=False, data=most_listened_songs, hue='artist_name', palette='viridis')
plt.title('Top 10 Most Listened Songs')
plt.xlabel('Total Listen Count')
plt.ylabel('Song Title')
plt.show()

# 2. Most popular artists
most_popular_artists = (
    data.groupby('artist_name')
    .agg({'play_count': 'sum'})
    .reset_index()
    .sort_values(by='play_count', ascending=False)
    .head(10)
)

# Visualization: Most Popular Artists
plt.figure(figsize=(10, 6))
sns.barplot(x='play_count', y='artist_name',legend=False, hue='artist_name', data=most_popular_artists, palette='magma')
plt.title('Top 10 Most Popular Artists')
plt.xlabel('Total Listen Count')
plt.ylabel('Artist Name')
plt.show()

# 3. Distribution of Song Counts for Users
user_song_counts = data.groupby('user')['song'].nunique()

# Visualization: Distribution of Song Counts per User
plt.figure(figsize=(12, 6))
sns.histplot(user_song_count, bins=30, kde=True, color='green')
plt.title("Distribution of Song Counts Per User")
plt.xlabel("Number of Songs")
plt.ylabel("Number of Users")
plt.tight_layout()
plt.show()

# Display results for task 1
print("Most Listened Songs:\n", most_listened_songs)

print("\nMost Popular Artists:\n", most_popular_artists)

print("\nSong Count Distribution (User Stats):\n", user_song_counts.describe())

"""POPULARITY BASED RECCOMENDATION ENGINE"""

# Function to recommend popular songs for a specific user
def recommend_popular_songs(user_id, data, top_n=10):
    # Songs the user has listened to
    user_songs = data[data['user'] == user_id]['song'].unique()

    # Songs the user has not listened to
    songs_not_listened = data[~data['song'].isin(user_songs)]

    # Aggregate play counts for the remaining songs (using play_count instead of listen_count)
    popular_songs = songs_not_listened.groupby('song').agg({'play_count': 'sum'}).reset_index()
    popular_songs = popular_songs.sort_values(by='play_count', ascending=False).head(top_n)

    # Merge with song details
    recommendations = popular_songs.merge(data[['song', 'title', 'artist_name']].drop_duplicates(), on='song')

    # Display recommendations
    print("\nRecommended Songs (Popularity-Based) for User", user_id, ":\n", recommendations[['song', 'title', 'artist_name', 'play_count']])


# Function to interact with the dropdown
def select_user(user_id):
    # Clear the current output before updating
    clear_output(wait=True)
    # Call the recommendation function
    recommend_popular_songs(user_id, data)

# Get unique user IDs
user_ids = data['user'].unique()

# Create a dropdown for user selection
dropdown = widgets.Dropdown(
    options=user_ids,
    description='Select User:',
    disabled=False
)

# Interactive recommendation display
interact(select_user, user_id=dropdown)

"""# Function to recommend songs that the user has not listened to yet


"""

# Function to recommend songs that the user has not listened to yet
def recommend_songs_for_user(user_id, data, top_n=10):
    # Get the songs the user has already listened to
    user_songs = data[data['user'] == user_id]['song'].unique()

    # Filter out the songs the user has already listened to
    songs_not_listened = data[~data['song'].isin(user_songs)]

    # Aggregate play counts for the songs the user hasn't listened to
    popular_songs = songs_not_listened.groupby('song').agg({'play_count': 'sum'}).reset_index()
    popular_songs = popular_songs.sort_values(by='play_count', ascending=False).head(top_n)

    # Merge with song details (title, artist, etc.)
    recommendations = popular_songs.merge(data[['song', 'title', 'artist_name']].drop_duplicates(), on='song')

    # Display the recommendations
    print(f"\nRecommended Songs (Based on Popularity) for User {user_id}:\n")
    print(recommendations[['song', 'title', 'artist_name', 'play_count']])

# Function to interact with the dropdown and update recommendations
def select_user_for_recommendations(user_id):
    # Clear the current output before updating
    clear_output(wait=True)
    # Call the recommendation function
    recommend_songs_for_user(user_id, data)

# Get unique user IDs
user_ids = data['user'].unique()

# Create a dropdown for user selection
dropdown = widgets.Dropdown(
    options=user_ids,
    description='Select User:',
    disabled=False
)

# Interactive recommendation display
interact(select_user_for_recommendations, user_id=dropdown)

# Prepare the data for Surprise (user, song, play_count)
reader = Reader(rating_scale=(data['play_count'].min(), data['play_count'].max()))
dataset = Dataset.load_from_df(data[['user', 'song', 'play_count']], reader)

# Split the data into train and test sets
trainset, testset = train_test_split(dataset, test_size=0.2)

# Train the SVD model
svd = SVD()
svd.fit(trainset)

# Function to get recommendations for a user
def get_recommendations(user_id, data, svd, top_n=10):
    # Get the songs already listened to by the user
    songs_listened_by_user = data[data['user'] == user_id]['song'].unique()

    # Generate predictions for all songs the user has not listened to
    all_songs = data['song'].unique()
    songs_not_listened = [song for song in all_songs if song not in songs_listened_by_user]

    # Get the predicted ratings for the songs the user hasn't listened to yet
    predicted_ratings = []
    for song in songs_not_listened:
        predicted_rating = svd.predict(user_id, song).est
        predicted_ratings.append((song, predicted_rating))

    # Sort the predictions by predicted rating (highest first)
    recommended_songs = sorted(predicted_ratings, key=lambda x: x[1], reverse=True)

    # Return the top N recommended songs
    return recommended_songs[:top_n]

# Streamlit Web App
st.title('Song Recommendation System (SVD)')

# Dropdown to select the user
user_ids = data['user'].unique()
selected_user = st.selectbox("Select User ID", user_ids)

# Display the recommendations for the selected user
if selected_user is not None:
    recommendations = get_recommendations(selected_user, data, svd)
    st.subheader(f"Top 10 Recommended Songs for User {selected_user}:")

    # Display recommended songs
    for song_id, predicted_rating in recommendations:
        song_title = data[data['song'] == song_id]['title'].iloc[0]
        song_artist = data[data['song'] == song_id]['artist_name'].iloc[0]
        st.write(f"Song: {song_title} by {song_artist}, Predicted Rating: {predicted_rating:.2f}")
